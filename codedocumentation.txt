Cale Stringfellow, Alex Landry, Katherine Liggs

Code Documentation

	Our code was entirely written into one python file my_node.py. This file controls the entirety of the robot’s logic. The code starts with defining __init__, which runs upon initialization of the node. It declares internal variables and parameters as well as some subscribers and publishers for ros. The bumper_callback definition runs when the bumper detects a collision and sets the “bumped” variable to true. The laser_callback definition returns the ranges of all the lasers from the laser node. The run definition is constantly ran to loop through the priority list of behaviors, starting with halting if the bumped is true, then escaping symmetric obstacles, then escaping asymmetric obstacles, then randomly turning every 1ft, then finally just driving forward.
	Next comes the definitions of the behavior helpers. detect_symmetric_obstacle uses laser_callback’s data and returns true if anything is close to colliding with it, with more lenience for objects that are to the front-left or front-right. escape_turn just sets the angle to the previous angle plus 180 degrees. detect_asymmetric_obstacle does the same as the symmetric variant but only splits between the left and right and is less lenient. avoid_turn changes the turn speed based on whether or not an avoidable obstacle is to the left or right. should_random_turn is the definition that checks if it’s been enough time since the last turn and returns true if it has been. Finally, the “if __name__ == ‘__main__’:” definition handles errors related to not being able to run the robot controller.
	We went with a subsumption style architecture. We chose this because it seemed to be the architecture that lined up the most with what the project instructions asked us to do. In subsumption style architecture, the control is local, continuous, and driven by whatever the sensors are finding. It also implements the priority behavior system that we were instructed to write. The small, periodic control loop run() accomplishes this constant priority checking, and higher priority checks like halting after a bumper collision are evaluated before lower priority checks like if it should do another random turn. Sensors like the laser sensor and the bumper sensor are constantly factored into the core loop to check if an operation like moving around an obstacle needs to take place. There is no deliberative architecture to be found in this project as there is no operation given to us that requires reasoning. Every action the robot takes is reactive.
